1. Сортировка выбором (Selection Sort)

Это алгоритм упорядочивания элементов массива, при котором на каждом шаге находится минимальный (или максимальный) элемент из ещё неотсортированной части массива и меняется местами с первым элементом этой части.

Основные действия: внешний цикл   for (int i = 0; i < n - 1; i++) проходит по индексам массива, внутренний цикл for (int j = i + 1; j < n; j++) ищет минимальный элемент в оставшейся части, после чего происходит обмен значений.

Временная сложность: O(n²).

Объяснение: Для каждого из n элементов выполняется поиск минимума среди оставшихся (в среднем n/2 сравнений), что даёт квадратичную зависимость.

2. Сортировка обменом (Пузырьком) (Bubble Sort)

Определение:
Это класс алгоритмов сортировки, основанных на многократном сравнении пар элементов и их обмене местами, если они расположены в неправильном порядке.
Язык реализации: Python

Основные действия: два вложенных цикла for i in range(n) и for j in range(0, n - i - 1):; внутренний цикл for j in range(0, n - i - 1) сравнивает arr[j] и arr[j+1] и при необходимости меняет их местами.

Временная сложность: O(n²).

Объяснение: В худшем случае, как и сортировка выбором, требует n*(n-1)/2 сравнений и потенциальных обменов.

3. Сортировка вставками (Insertion Sort)

Определение:
алгоритм сортировки, в котором элементы входной последовательности просматриваются по одному, и каждый новый поступивший элемент размещается в подходящее место среди ранее упорядоченных элементов.

Основные действия: цикл for (int i = 1; i < n; i++) перебирает элементы начиная со второго; вложенный цикл while (j >= 0 && arr[j] > key) сдвигает элементы вправо, пока не найдёт правильную позицию для вставки.

Временная сложность: O(n²).

Объяснение: общее количество сдвигов и сравнений составляет 1 + 2 + 3 + ... + (n-1) = n*(n-1)/2.

4. Сортировка слиянием (Merge Sort)

Определение:
алгоритм сортировки, который упорядочивает списки (или другие структуры данных, доступ к элементам которых можно получать только последовательно, например — потоки) в определённом порядке. 

Основные действия: цикл for (int i = 0; i < n1; i++) перебирает элементы начиная со второго; вложенный цикл while (i < n1 && j < n2) сдвигает элементы вправо, пока не найдёт правильную позицию для вставки.

Временная сложность: O(n log n).

Объяснение: массив делится log n раз (глубина рекурсии), и на каждом уровне выполняется линейное слияние всех элементов (n операций).

5. Сортировка Шелла (Shell Sort)

Определение:
алгоритм сортировки, являющийся усовершенствованным вариантом сортировки вставками. Идея метода Шелла состоит в сравнении элементов, стоящих не только рядом, но и на определённом расстоянии друг от друга.

Основные действия: внешний цикл for управляет шагом gap; внутренний цикл for применяет сортировку вставками к элементам, отстоящим на gap друг от друга.

Временная сложность:O(n²)

Объяснение: Алгоритм использует вложенные циклы, но внутренний цикл (по j) не всегда проходит n раз, как в пузырьке. Количество итераций зависит от gap. В среднем случае количество итераций внутреннего цикла растет медленнее, чем n, приводя к сложности между O(n) и O(n^2).

6. Быстрая сортировка (Quick Sort)

Определение:
это эффективный рекурсивный алгоритм сортировки, основанный на принципе «разделяй и властвуй». Он выбирает опорный элемент (pivot) и разделяет массив на две части: элементы, меньшие опорного, и элементы, большие (или равные) ему. Затем алгоритм рекурсивно применяется к обеим частям.

Основные действия: рекурсивная функция quick_sort(arr, low, high): вызывает функциюdef partition(arr, low, high):, которая переставляет элементы относительно опорного с помощью цикла for j in range(low, high): и обменов.

Временная сложность: O(n log n)
Объяснение: Глубина рекурсии log n, на каждом уровне n сравнений (в partition).

7. Пирамидальная сортировка (Heap Sort)

Определение:
Это алгоритм сортировки, основанный на структуре данных бинарная куча

Основные действия: функция heapify(std::vector<int>& arr, int n, int i) рекурсивно восстанавливает свойство кучи в поддереве; основной цикл for (int i = n - 1; i > 0; i--): извлекает корень и перемещает его в конец.

Временная сложность: O(n log n).

Объяснение:  Цикл for выполняется n-1 раз. Внутри него вызывается heapify, который работает за O(log n) (глубина дерева). Итого n * O(log n) = O(n log n).

8. Последовательный поиск (Линейный поиск) (Linear Search)

Определение:
алгоритм нахождения заданного значения произвольной функции на некотором отрезке.

Основные действия: цикл for i in range(len(arr)) проходит по всем индексам массива и сравнивает arr[i] с целевым значением.

Временная сложность: O(n).

Объяснение: в худшем случае требуется проверить все n

9. Бинарный поиск (Binary Search)

Определение:
классический алгоритм поиска элемента в отсортированном массиве (векторе), использующий дробление массива на половины.

Основные действия: цикл while управляет границами поиска (left, right); вычисляется mid = left + (right − left)/2 и сравнивается arr[mid] с целевым значением.


10. Интерполирующий поиск (Interpolation Search)
Определение:
это алгоритм поиска элемента в отсортированном массиве, который улучшает идею бинарного поиска за счёт более «умного» выбора позиции проверки, основываясь на предположении о равномерном распределении значений.

Основные действия: вычисляется предполагаемуа позиция pos по формуле интерполяции и сравнивает arr[pos] с искомым значением.

Временная сложность: O(log log n)
Объяснение: при распределении каждый шаг сильно сужает область поиска

11. Поиск по Фибоначчи (Fibonacci Search)

Определение:
это метод поиска в отсортированном массиве с использованием алгоритма «разделяй и властвуй», который сужает круг возможных местоположений с помощью чисел Фибоначчи.

Основные действия: предварительно определяются три последовательных числа Фибоначчи; в цикле while индекс i = offset + fib_m2 используется для сравнения; границы сдвигаются с пересчётом чисел Фибоначчи.

Временная сложность: O(log n).

Объяснение: количество шагов пропорционально индексу числа Фибоначчи, превышающего длину массива, что растёт логарифмически.
