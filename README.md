1. Сортировка выбором (Selection Sort)

Описание алгоритма: Алгоритм работает, находя минимальный элемент из неотсортированной части массива и меняя его местами с первым элементом этой неотсортированной части. Процесс повторяется, начиная с элемента следующего за уже отсортированным фрагментом.
Язык реализации: Java

Описание кода:
selectionSort: Основной метод сортировки.
for (int i = 0; i < n - 1; i++): Внешний цикл проходит по каждому элементу массива, за исключением последнего.
int minIndex = i;: Инициализация индекса минимального элемента как текущего (i).
for (int j = i + 1; j < n; j++): Внутренний цикл ищет минимальный элемент в оставшейся части массива (от i+1 до n-1).
if (arr[j] < arr[minIndex]): Проверяет, является ли текущий элемент arr[j] меньше найденного на данный момент минимального arr[minIndex].
minIndex = j;: Если да, обновляется индекс минимального элемента.
if (minIndex != i): После завершения внутреннего цикла проверяется, нашёлся ли элемент, который меньше arr[i]. Если да, они меняются местами.

Оценка сложности по Big O:
Временная сложность: O(n²). 


2. Сортировка обменом (Пузырьком) (Bubble Sort)

Описание алгоритма: Алгоритм многократно проходит по списку, сравнивая соседние элементы и меняя их местами, если они находятся в неправильном порядке. На каждой итерации самый "тяжёлый" элемент "всплывает" в конец неотсортированной части массива.
Язык реализации: Python

Описание кода:
bubble_sort: Основная функция сортировки.
n = len(arr): Получает длину массива.
for i in range(n): Внешний цикл управляет количеством проходов.
swapped = False: Флаг, показывающий, происходил ли обмен на текущей итерации.
for j in range(0, n - i - 1): Внутренний цикл проходит по неотсортированной части массива. n - i - 1 учитывает, что i самых больших элементов уже находятся на своих местах в конце.
if arr[j] > arr[j + 1]:: Сравнивает текущий элемент с соседним.
arr[j], arr[j + 1] = arr[j + 1], arr[j]: Если текущий элемент больше следующего, они меняются местами.
swapped = True: Устанавливает флаг, если произошёл обмен.
if not swapped: break: Если за весь проход не было обменов, массив отсортирован, и можно выйти из цикла.
if __name__ == "__main__": Проверяет, запущен ли скрипт напрямую, и если да, создаёт тестовый массив, сортирует его и выводит результаты.

Оценка сложности по Big O:
Временная сложность:
O(n²).


3. Сортировка вставками (Insertion Sort)

Описание алгоритма: Алгоритм строит отсортированный массив по одному элементу за раз. Он начинает с первого элемента (считая его отсортированным) и поочерёдно берёт каждый следующий элемент, вставляя его на правильное место в уже отсортированной части массива.
Язык реализации: C++ 

Описание кода:
insertionSort: Основная функция сортировки.
for (int i = 1; i < n; i++): Внешний цикл проходит по элементам массива, начиная со второго (i=1), так как первый элемент считается отсортированным.
int key = arr[i];: Сохраняет текущий элемент, который нужно вставить в отсортированную часть.
int j = i - 1;: Индекс последнего элемента в отсортированной части массива.
while (j >= 0 && arr[j] > key): Внутренний цикл сдвигает элементы в отсортированной части вправо, пока не найдётся место для key.
arr[j + 1] = arr[j];: Сдвигает элемент вправо.
j--;: Переходит к предыдущему элементу в отсортированной части.
arr[j + 1] = key;: После завершения внутреннего цикла j+1 указывает на правильное место для key, и элемент вставляется туда.
printArray: Вспомогательная функция для вывода элементов вектора.
main: Создаёт тестовый вектор, выводит его, вызывает insertionSort, и снова выводит результат.

Оценка сложности по Big O:
Временная сложность:
O(n²).



4. Сортировка слиянием (Merge Sort)

Описание алгоритма: Это алгоритм "разделяй и властвуй". Он рекурсивно делит массив на две половины до тех пор, пока каждая половина не будет содержать один элемент (или быть пустой), а затем сливает эти половины обратно в отсортированный массив.
Язык реализации: Java

Описание кода:
mergeSort(int[] arr, int left, int right): Рекурсивная функция.
if (left < right): Базовый случай рекурсии. Если left >= right, подмассив содержит 0 или 1 элемент, и он считается отсортированным.
int mid = left + (right - left) / 2;: Находит индекс середины подмассива.
mergeSort(arr, left, mid);: Рекурсивно сортирует левую половину.
mergeSort(arr, mid + 1, right);: Рекурсивно сортирует правую половину.
merge(arr, left, mid, right);: Сливает две отсортированные половины.
merge(int[] arr, int left, int mid, int right): Функция слияния.
int n1 = mid - left + 1;, int n2 = right - mid;: Вычисляет размеры левой и правой половин.
int[] leftArr = new int[n1];, int[] rightArr = new int[n2];: Создаёт временные массивы для хранения данных половин.
Циклы for копируют данные из основного массива в временные.
int i = 0, j = 0, k = left;: Индексы для leftArr, rightArr и основного массива arr.
Основной цикл while (i < n1 && j < n2): Сравнивает элементы из временных массивов и помещает меньший (или равный) в основной массив arr.
Циклы while после основного: Копируют оставшиеся элементы из leftArr или rightArr, если такие остались.
main: Создаёт тестовый массив, выводит его, вызывает mergeSort, и снова выводит результат.

Оценка сложности по Big O:
Временная сложность: O(n log n)


5. Сортировка Шелла (Shell Sort)

Описание алгоритма: Это улучшенная версия сортировки вставками. Вместо сравнения только соседних элементов, она сравнивает элементы, находящиеся на определённом расстоянии gap. Этот gap уменьшается на каждом шаге (обычно делится на 2) до тех пор, пока не станет равным 1, после чего алгоритм становится обычной сортировкой вставками, но массив к этому моменту уже более-менее отсортирован.
Язык реализации: Python


Описание кода:
shell_sort: Основная функция сортировки.
n = len(arr): Получает длину массива.
gap = n // 2: Инициализирует начальный gap как половину размера массива.
while gap > 0: Цикл продолжается, пока gap не станет 0.
for i in range(gap, n): Проходит по элементам, начиная с gap. Элементы с индексами 0 до gap-1 служат "якорями" для сравнений.
temp = arr[i]: Сохраняет текущий элемент, который нужно вставить.
j = i: Индекс для поиска правильного места в текущей подпоследовательности.
while j >= gap and arr[j - gap] > temp: Внутренний цикл сдвигает элементы, которые больше temp, на gap позиций вправо.
arr[j] = arr[j - gap]: Сдвигает элемент.
j -= gap: Переходит к следующему элементу в подпоследовательности.
arr[j] = temp: После выхода из внутреннего цикла j указывает на правильное место для temp, и элемент вставляется туда.
gap //= 2: Уменьшает gap для следующей итерации внешнего цикла.
if __name__ == "__main__": Создаёт тестовый массив, выводит его, вызывает shell_sort, и снова выводит результат.

Оценка сложности по Big O:
Временная сложность: 
O(n log n)


6. Быстрая сортировка (Quick Sort)

Описание алгоритма: Также алгоритм "разделяй и властвуй". Он выбирает "опорный" (pivot) элемент из массива и разделяет массив на две части: элементы, меньшие или равные опорному, и элементы, большие опорного. Затем рекурсивно применяет ту же процедуру к полученным подмассивам.
Язык реализации: Python

Описание кода:
quick_sort(arr, low, high): Рекурсивная функция.
if low < high: Базовый случай. Если low >= high, подмассив пуст или содержит один элемент.
pi = partition(arr, low, high): Вызывает функцию partition, которая разбивает массив и возвращает индекс опорного элемента.
quick_sort(arr, low, pi - 1): Рекурсивно сортирует левую часть (до опорного).
quick_sort(arr, pi + 1, high): Рекурсивно сортирует правую часть (после опорного).
partition(arr, low, high): Функция разбиения.
pivot = arr[high]: Выбирает последний элемент как опорный.
i = low - 1: Индекс элемента, который будет слева от опорного (или на его месте). Инициализируется так, чтобы указывать "до начала".
for j in range(low, high): Проходит по элементам от low до high-1.
if arr[j] <= pivot: Если текущий элемент arr[j] меньше или равен опорному.
i += 1: Увеличивает индекс i.
arr[i], arr[j] = arr[j], arr[i]: Меняет местами arr[i] и arr[j]. Это помещает arr[j] (меньший или равный pivot) в левую часть, а arr[i] (который был большим) в правую.
arr[i + 1], arr[high] = arr[high], arr[i + 1]: После цикла i+1 указывает на первую позицию, где arr[i+1] больше pivot. Меняет местами опорный элемент arr[high] с arr[i+1], помещая опорный на его окончательное место.
return i + 1: Возвращает индекс, на котором теперь находится опорный элемент.
if __name__ == "__main__": Создаёт тестовый массив, выводит его, вызывает quick_sort, и снова выводит результат.

Оценка сложности по Big O:
Временная сложность:
O(n log n)


7. Пирамидальная сортировка (Heap Sort)

Описание алгоритма: Сначала строится двоичная куча (обычно max-heap, где родитель больше своих детей) из исходного массива. Затем максимальный элемент (корень кучи) извлекается и помещается в конец массива. Процесс повторяется для оставшейся части массива, пока куча не станет пустой.
Язык реализации: C++


Описание кода:
heapify(std::vector<int>& arr, int n, int i): Рекурсивная функция, которая "просеивает" элемент arr[i] вниз по дереву, чтобы поддерево с корнем в i стало max-heap.
int largest = i;: Предполагается, что i - индекс наибольшего элемента.
int left = 2 * i + 1;, int right = 2 * i + 2;: Вычисляются индексы левого и правого дочерних узлов.
if (left < n && arr[left] > arr[largest]): Проверяет, больше ли левый потомок, чем текущий largest.
if (right < n && arr[right] > arr[largest]): Проверяет, больше ли правый потомок, чем текущий largest.
if (largest != i): Если largest изменился (т.е. один из потомков был больше корня i), нужно поменять местами arr[i] и arr[largest], и затем рекурсивно вызвать heapify для поддерева с корнем largest, чтобы восстановить свойство кучи в этом поддереве.
heapSort(std::vector<int>& arr): Основная функция сортировки.
int n = arr.size();: Получает размер массива.
for (int i = n / 2 - 1; i >= 0; i--): Цикл строит max-heap. Начинается с последнего узла, у которого есть потомки (n/2 - 1), и применяет heapify ко всем внутренним узлам, двигаясь вниз.
for (int i = n - 1; i > 0; i--): Цикл извлекает элементы из кучи.
std::swap(arr[0], arr[i]);: Меняет местами корень (максимальный элемент) с последним элементом неотсортированной части массива.
heapify(arr, i, 0);: Вызывает heapify для уменьшенной кучи (размером i, так как arr[i] теперь на своём месте), чтобы восстановить свойство max-heap.
printArray, main: Вспомогательные функции для вывода и тестирования.

Оценка сложности по Big O:
Временная сложность: O(n log n)



8. Последовательный поиск (Линейный поиск) (Linear Search)

Примечание: Последовательный поиск не является сортировкой, а является алгоритмом поиска. Однако, он представлен в файле. Мы опишем его в стиле сортировок.
Описание алгоритма: Алгоритм последовательно просматривает элементы массива один за другим, начиная с первого, и сравнивает каждый с искомым значением (ключом). Поиск завершается, когда элемент найден или просмотрен весь массив.
Язык реализации: Python

Описание кода:
linear_search: Функция принимает список arr и искомое значение target.
for i in range(len(arr)): Цикл проходит по индексам элементов массива.
if arr[i] == target:: Проверяет, совпадает ли текущий элемент arr[i] с искомым target.
return i: Если совпадение найдено, функция возвращает индекс i.
return -1: Если цикл завершается, и элемент не найден, функция возвращает -1.
if __name__ == "__main__": Блок проверяет, запущен ли скрипт напрямую. Он создает тестовый массив и искомое значение, вызывает linear_search и выводит результат.

Оценка сложности по Big O:
Временная сложность:
O(n)


9. Бинарный поиск (Binary Search)

Описание алгоритма: Алгоритм эффективно находит элемент в отсортированном массиве, многократно деля его пополам. Он сравнивает искомое значение с элементом в середине массива и отбрасывает половину, где искомого элемента точно нет. Процесс повторяется для оставшейся половины.
Язык реализации: C++

Описание кода:
binarySearch: Функция принимает отсортированный вектор arr и искомое значение target.
int left = 0;, int right = arr.size() - 1;: Инициализируют границы области поиска.
while (left <= right): Цикл продолжается, пока границы не пересекутся.
int mid = left + (right - left) / 2;: Вычисляет индекс середины текущего диапазона. (right - left) предотвращает потенциальное переполнение при сложении больших чисел.
if (arr[mid] == target): Проверяет, совпадает ли элемент в середине с искомым.
else if (arr[mid] < target): Если искомый элемент больше среднего, поиск продолжается в правой половине (left = mid + 1).
else: Если искомый элемент меньше среднего, поиск продолжается в левой половине (right = mid - 1).
return -1;: Если элемент не найден, возвращается -1.
main: Создает отсортированный вектор, выводит его, вызывает binarySearch и печатает результат.

Оценка сложности по Big O:
Временная сложность: 
O(log n)


10. Интерполирующий поиск (Interpolation Search)

Описание алгоритма: Это улучшенная версия бинарного поиска для отсортированных массивов с равномерно распределёнными значениями. Вместо деления массива пополам, он "предсказывает" приблизительное положение искомого элемента, используя линейную интерполяцию. Это может привести к более быстрому сужению области поиска.
Язык реализации: Java

Описание кода:
interpolationSearch: Рекурсивная функция. Принимает массив, искомое значение, и границы текущего диапазона поиска (low, high).
if (low <= high && target >= arr[low] && target <= arr[high]): Базовое условие остановки. Проверяет, может ли искомый элемент находиться в текущем диапазоне.
int pos = low + ((target - arr[low]) / (arr[high] - arr[low])) * (high - low);: Формула интерполяции для вычисления приблизительной позиции target. Она моделирует линейную зависимость между индексами и значениями.
if (arr[pos] == target): Проверяет, совпадает ли элемент в вычисленной позиции pos с искомым.
if (arr[pos] > target): Если элемент в pos больше искомого, рекурсивно ищем в левой части (low до pos-1).
else: Если элемент в pos меньше искомого, рекурсивно ищем в правой части (pos+1 до high).
return -1;: Если элемент не найден в текущем диапазоне, возвращается -1.
main: Создает отсортированный массив, выводит его, вызывает interpolationSearch и печатает результат.

Оценка сложности по Big O:
Временная сложность:
O(log log n)


11. Поиск по Фибоначчи (Fibonacci Search)

Описание алгоритма: Похож на бинарный поиск, но вместо деления массива пополам, он делит его на части, размеры которых соответствуют числам Фибоначчи (F(k), F(k-1), F(k-2)). Это позволяет эффективно сужать область поиска.
Язык реализации: Python

Описание кода:
fibonacci_search: Основная функция. Принимает отсортированный список arr и искомое значение target.
n = len(arr): Получает размер массива.
Блок # 1: Находит первое число Фибоначчи fib_m, которое больше или равно n. fib_m2, fib_m1 хранят предыдущие числа Фибоначчи.
offset = -1: Инициализирует смещение. Оно отслеживает, сколько элементов слева было отброшено.
while fib_m > 1: Цикл продолжается, пока размер текущего сегмента (представляемого fib_m) больше 1.
i = min(offset + fib_m2, n - 1): Вычисляет индекс элемента для сравнения. Он находится на расстоянии fib_m2 от offset.
if arr[i] < target: Если искомый элемент больше arr[i], он находится в правой части. Обновляем fib_m, fib_m1, fib_m2 как для следующего шага поиска в правой части и сдвигаем offset на i.
elif arr[i] > target: Если искомый элемент меньше arr[i], он находится в левой части. Обновляем fib_m, fib_m1, fib_m2 как для следующего шага поиска в левой части.
else: return i: Если arr[i] равен target, элемент найден.
Блок # 7: После выхода из цикла while может остаться один элемент (offset + 1), который нужно проверить отдельно. Условие fib_m1 and ... проверяет, существует ли этот элемент и совпадает ли он с target.
return -1: Если элемент не найден, возвращается -1.
if __name__ == "__main__": Создает отсортированный список, выводит его, вызывает fibonacci_search и печатает результат.

Оценка сложности по Big O:
Временная сложность: 
O(log n).
